package storage

import (
	"context"
	"database/sql"
	"log"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/WeisseNacht18/gophermart/internal/entities"
	_ "github.com/jackc/pgx/v5/stdlib"
)

var DB *sql.DB

func NewDatabaseStorage(dsn string) {
	database, err := sql.Open("pgx", dsn)
	if err != nil {
		log.Fatalln(err)
	}

	DB = database

	const query = `CREATE TABLE IF NOT EXISTS public.users
			(
				user_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
				login character varying COLLATE pg_catalog."default" NOT NULL,
				pass character varying COLLATE pg_catalog."default" NOT NULL,
				CONSTRAINT user_pk PRIMARY KEY (user_id)
			);
			CREATE TABLE IF NOT EXISTS public.orders
			(
				order_id character varying COLLATE pg_catalog."default" NOT NULL,
				user_id integer NOT NULL,
				status character varying NOT NULL,
				accrual real,
				uploaded_at timestamp NOT NULL default current_timestamp,
				CONSTRAINT order_pk PRIMARY KEY (order_id),
				CONSTRAINT user_fk FOREIGN KEY (user_id) REFERENCES users(user_id)
			);
			CREATE TABLE IF NOT EXISTS public.balance
			(
				balance_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ), 
				user_id integer NOT NULL,
				balance real NOT NULL default 0.0,
				withdrawn real NOT NULL default 0.0,
				CONSTRAINT balance_pk PRIMARY KEY (balance_id),
				CONSTRAINT user_fk FOREIGN KEY (user_id) REFERENCES users(user_id)
			);
			CREATE TABLE IF NOT EXISTS public.withdraws
			(
				withdraw_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ), 
				user_id integer NOT NULL,
				order_id character varying NOT NULL,
				sum real NOT NULL default 0.0,
				processed_at timestamp NOT NULL default current_timestamp,
				CONSTRAINT withdraw_pk PRIMARY KEY (withdraw_id),
				CONSTRAINT user_fk FOREIGN KEY (user_id) REFERENCES users(user_id)
			);
			`

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	_, err = DB.ExecContext(ctx, query)
	if err != nil {
		log.Fatalln(err)
	}
}

func NewMockDatabaseStorage() {
	database, _, err := sqlmock.New()
	if err != nil {
		log.Fatalln(err)
	}

	DB = database

	const query = `CREATE TABLE IF NOT EXISTS public.users
			(
				user_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
				login character varying COLLATE pg_catalog."default" NOT NULL,
				pass character varying COLLATE pg_catalog."default" NOT NULL,
				CONSTRAINT user_pk PRIMARY KEY (user_id)
			);
			CREATE TABLE IF NOT EXISTS public.orders
			(
				order_id character varying COLLATE pg_catalog."default" NOT NULL,
				user_id integer NOT NULL,
				CONSTRAINT order_pk PRIMARY KEY (order_id),
				CONSTRAINT user_fk FOREIGN KEY (user_id) REFERENCES users(user_id)
			);
			`

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	_, err = DB.ExecContext(ctx, query)
	if err != nil {
		log.Fatalln(err)
	}
}

func AddUser(login string, password string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	const query = "INSERT INTO users (login, pass) VALUES ($1, $2)"
	_, err := DB.ExecContext(ctx, query, login, password)

	return err
}

func GetUserPassword(login string) (password string, err error) {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	const query = "SELECT pass FROM users WHERE login = $1 LIMIT 1"
	row := DB.QueryRowContext(ctx, query, login)

	err = row.Scan(&password)
	if err != nil {
		return "", err
	}

	return
}

func GetUserId(login string) (id int, err error) {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	const query = "SELECT user_id FROM users WHERE login = $1 LIMIT 1"
	row := DB.QueryRowContext(ctx, query, login)

	err = row.Scan(&id)
	if err != nil {
		return -1, err
	}

	return
}

func CheckUser(login string) (isExist bool) {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	const query = "SELECT login FROM users WHERE login = $1 LIMIT 1"
	row := DB.QueryRowContext(ctx, query, login)

	var user string

	err := row.Scan(&user)

	if err == nil {
		return true
	}

	return false
}

func AddOrder(order entities.Order, userId int) error {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	const query = "INSERT INTO orders (order_id, user_id, status, accrual) VALUES ($1, $2, $3, $4)"
	_, err := DB.ExecContext(ctx, query, order.ID, userId, order.Status, order.Accrual)

	return err
}

func UpdateOrder(order entities.Order) error {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	const query = "UPDATE orders SET status = $1, accrual = $2 WHERE order_id = $3"
	_, err := DB.ExecContext(ctx, query, order.Status, order.Accrual, order.ID)

	return err
}

func GetOrder(orderID string) (userId int, err error) {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	const query = "SELECT user_id FROM orders WHERE order_id = $1 LIMIT 1"
	row := DB.QueryRowContext(ctx, query, orderID)

	err = row.Scan(&userId)

	return
}

func GetAllOrders(userID int) (orders []entities.Order) {
	orders = []entities.Order{}

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	rows, err := DB.QueryContext(ctx, "SELECT order_id, status, accrual, uploaded_at FROM orders WHERE user_id = $1", userID)
	if err != nil || rows.Err() != nil {
		return orders
	}

	for rows.Next() {
		var order entities.Order
		err = rows.Scan(&order.ID, &order.Status, &order.Accrual, &order.UploadedAt)
		if err != nil {
			return []entities.Order{}
		}

		orders = append(orders, order)
	}

	return
}

func MakeBalance(userID int) (err error) {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	const query = "INSERT INTO balance (user_id) VALUES ($1)"
	_, err = DB.ExecContext(ctx, query, userID)

	return
}

func UpdateBalance(userID int, current float32, withdrawn float32) (err error) {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	const query = "UPDATE balance SET balance = $1, withdrawn = $2 WHERE user_id = $3"
	_, err = DB.ExecContext(ctx, query, current, withdrawn, userID)

	return
}

func GetBalance(userID int) (balance entities.Balance, err error) {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	const query = "SELECT balance, withdrawn FROM balance WHERE user_id = $1 LIMIT 1"
	row := DB.QueryRowContext(ctx, query, userID)

	err = row.Scan(&balance.Current, &balance.Withdrawn)

	log.Println(err)

	return
}

func AddWithdraw(userID int, orderID string, sum float32) (err error) {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	log.Println("First inner point")

	const query = "INSERT INTO withdraws (user_id, order_id, sum) VALUES ($1, $2, $3)"
	_, err = DB.ExecContext(ctx, query, userID, orderID, sum)

	log.Println(err)

	return
}

func GetAllWithdraws(userID int) (withdraws []entities.Withdraw) {
	withdraws = []entities.Withdraw{}

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	rows, err := DB.QueryContext(ctx, "SELECT order_id, sum, processed_at FROM withdraws WHERE user_id = $1", userID)
	if err != nil || rows.Err() != nil {
		return withdraws
	}

	for rows.Next() {
		var withdraw entities.Withdraw
		err = rows.Scan(&withdraw.OrderID, &withdraw.Sum, &withdraw.ProcessedAt)
		if err != nil {
			return []entities.Withdraw{}
		}

		withdraws = append(withdraws, withdraw)
	}

	return
}
